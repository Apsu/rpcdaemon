#!/usr/bin/env python2

# General
import logging
import pwd
import grp
from uuid import uuid4
from time import sleep
from itertools import cycle
from signal import signal, getsignal, SIGTERM, SIGINT

# Daemonizing
from daemon import DaemonContext
from daemon.pidlockfile import TimeoutPIDLockFile

# Datetime parsing
from dateutil.parser import parse as dateparse
from datetime import datetime, timedelta

# Threading
from threading import Thread, Semaphore

# Oslo
from ConfigParser import RawConfigParser

# Kombu
from kombu.mixins import ConsumerMixin
from kombu import Exchange, Queue, Connection

# Quantumclient
from quantumclient.v2_0.client import Client as Quantum


# Indexable config parser
class Config(RawConfigParser):
    def __init__(self, file='/etc/quantum/quantum.conf', section='AGENT', logger=None):
        self.logger = logger
        RawConfigParser.__init__(self)  # Old-style class
        if self.read(file) and section in self.sections():
            self._config = dict(self.items(section))
        else:
            if logger:
                self.logger.error('Failed to parse config file: %s' % file)
            exit(1)

    def __getitem__(self, item):
        return self._config[item]


# Consumer worker
class Worker(ConsumerMixin, Thread):
    def __init__(self, connection):
        Thread.__init__(self, target=self.run)  # MRO picks mixin.run
        self.connection = connection
        self.exchange = Exchange(
            name='quantum',
            channel=connection.channel(),
            durable=False,
            type='topic'
        )
        self.queues = [Queue(
            name=('l3-daemon_%s' % uuid4()),
            exchange=self.exchange,
            auto_delete=True,
            durable=False,
            routing_key='q-plugin'
        )]
        self.agents = {}
        self.lock = Semaphore()

    def get_consumers(self, Consumer, channel):
        return [Consumer(queues=self.queues, callbacks=[self.update_states])]

    def update_states(self, body, message):
        if body['method'] == 'report_state':
            state = body['args']['agent_state']['agent_state']
            time = body['args']['time']
            host = state['host']
            type = state['agent_type']  # Ok to override builtin, honest

            # L3 agents only
            if type == 'L3 agent':
                self.lock.acquire()  # Lock
                if not host in self.agents:
                    self.agents[host] = {}
                self.agents[host][type] = {
                    'heartbeat_timestamp': dateparse(time),
                    'alive': True
                }
                self.lock.release()  # Unlock
        else:
            # Skip other RPC methods
            pass
        message.ack()


# State monitor
class Monitor(DaemonContext):
    def __init__(self):
        # Setup logging
        self.logger = logging.getLogger('l3-daemon')
        self.logger.setLevel(logging.INFO)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler = logging.FileHandler('/var/log/l3-daemon.log')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.pidfile = TimeoutPIDLockFile(
            '/var/run/quantum/l3-daemon',
            acquire_timeout=0,
            threaded=False
        )

        # Initialize daemon
        DaemonContext.__init__(
            self,
            files_preserve=[handler.stream],
            uid=pwd.getpwnam('quantum').pw_uid,
            gid=grp.getgrnam('quantum').gr_gid,
            working_directory='/var/lib/quantum',
            pidfile=self.pidfile
        )

    def reschedule_routers(self, host, type):
        agents = self.quantum.list_agents(agent_type=type)['agents']
        mine = [agent for agent in agents if agent['host'] == host][0]
        if not mine:
            self.logger.warn('%s/%s not found.' % (host, type))
            return

        rest = [
            agent for agent in agents
            if not agent['host'] == host
            and agent['alive']
        ]
        routers = self.quantum.list_routers_on_l3_agent(mine['id'])['routers']

        # Any other agents alive?
        if rest:
            # Map my routers to other agents
            mapping = zip(routers, cycle(rest))

            # And move them
            for router, agent in mapping:
                self.logger.info(
                    'Rescheduling %s/%s(%s) -> %s.' % (
                        host,
                        router['name'],
                        router['id'],
                        agent['host']
                    )
                )
                self.quantum.remove_router_from_l3_agent(
                    mine['id'],
                    router['id']
                )
                self.quantum.add_router_to_l3_agent(
                    agent['id'],
                    {'router_id': router['id']}
                )
        elif routers:
            self.logger.warn(
                'No agents found to reschedule routers from %s/%s.' % (
                    host,
                    type
                )
            )

    def check_states(self):
        self.lock.acquire()  # Lock
        for host, agents in self.worker.agents.items():
            for type, info in agents.items():
                # Check timestamp + allowed down time against current time
                if (
                        info['heartbeat_timestamp'] +
                        self.downtime <
                        datetime.utcnow()
                ):
                    self.logger.debug('%s/%s: is down.' % (host, type))
                    self.worker.agents[host][type]['alive'] = False
                    self.reschedule_routers(host, type)
                else:
                    self.logger.debug('%s/%s: is up.' % (host, type))
                    self.worker.agents[host][type]['alive'] = True
        self.lock.release()  # Unlock

    def open(self):
        # Call super
        DaemonContext.open(self)
        self.logger.info('Starting...')

        self.config = Config(logger=self.logger)
        self.quantum = Quantum(
            username=self.config['admin_user'],
            password=self.config['admin_password'],
            tenant_name=self.config['admin_tenant_name'],
            auth_url=self.config['auth_url']
        )
        self.connection = Connection(self.config['rabbit_host'])
        self.worker = Worker(self.connection)
        self.lock = self.worker.lock  # Lock shared with thread worker

        # Populate L3 agents
        self.logger.debug('Prepopulating L3 agents.')
        for agent in self.quantum.list_agents(agent_type='L3 agent')['agents']:
            self.worker.agents[agent['host']] = ({
                agent['agent_type']: {
                    'heartbeat_timestamp': dateparse(
                        agent['heartbeat_timestamp']
                    ),
                    'alive': agent['alive']
                }
            })

        self.downtime = timedelta(seconds=int(self.config['agent_down_time']))
        self.timeout = int(self.config['agent_down_time'])
        self.worker.start()
        self.logger.info('Started.')

    def close(self):
        # Emulate super's close() behavior
        if self.is_open:
            self.logger.info('Stopping...')
            self.worker.should_stop = True
            self.worker.join()
            self.logger.info('Stopped.')

        DaemonContext.close(self)

# Entry point
if __name__ == '__main__':
    with Monitor() as monitor:
        while monitor.worker.is_alive():
            monitor.logger.debug('Checking states.')
            monitor.check_states()
            sleep(monitor.timeout)
